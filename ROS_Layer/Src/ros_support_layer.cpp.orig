#include "ros_support_layer.h"
#include <ros.h>
#include "geometry_msgs/Point.h"
#include <std_msgs/Float64.h>
#include <std_msgs/UInt8.h>
#define a_PARAMETER          (0.095f)
#define b_PARAMETER          (0.086f)
extern "C" {
    extern float Move_X,Move_Y,Move_Z;   //XYZ轴目标速度
    extern uint8_t Run_Flag;
    extern int RC_Velocity;
    extern uint8_t relative;
    extern uint8_t pending_flag;
    extern double Last_Target_X,Last_Target_Y,Last_Target_Z;
    extern long int Position_A,Position_B,Position_C,Position_D; //PID控制相关变量
}
void callback_pos(const geometry_msgs::Point& msg);
void callback_speed(const geometry_msgs::Point& msg);
void callback_speedlimit(const std_msgs::Float64& msg);
void callback_mode(const std_msgs::UInt8& msg);
ros::NodeHandle nh;
//ros::Subscriber<std_msgs::Float64> carspeed_sub("/car/speed", &callback_speed);
ros::Subscriber<geometry_msgs::Point> carpos_sub("/car/pos", &callback_pos);
ros::Subscriber<geometry_msgs::Point> carspeed_sub("/car/speed", &callback_speed);
ros::Subscriber<std_msgs::Float64> carspeedlimit_sub("/car/speedlimit", &callback_speedlimit);
ros::Subscriber<std_msgs::UInt8> carmode_sub("/car/mode", &callback_mode);
geometry_msgs::Point pos_msg;
ros::Publisher current_pos("cur_pos", &pos_msg);

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
    nh.getHardware()->flush();
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    nh.getHardware()->reset_rbuf();
}

void setup(void)
{
    nh.initNode();
    nh.subscribe(carspeed_sub);
    nh.subscribe(carpos_sub);
    nh.subscribe(carspeedlimit_sub);
    nh.subscribe(carmode_sub);
    nh.advertise(current_pos);
}

void loop(void)
{

    nh.spinOnce();


    //HAL_Delay(1000);
}
void callback_speed(const geometry_msgs::Point& msg)//cm/s
{
    Run_Flag=0;
    Move_X=msg.x/2.41660968;
    Move_Y=msg.y/2.41660968;
    Move_Z=msg.z;//waiting
}
void callback_pos(const geometry_msgs::Point& msg)//cm
{
    if(Run_Flag==0)//mode changed from speed mode
    {
        if(relative==0)//changed to abs pos
        {
            double NOW_X,NOW_Y,NOW_Z;
            NOW_X=(Position_B-Position_A)/2.0;
            NOW_Y=(Position_B+Position_C)/2.0;
            NOW_Z=(Position_C-Position_A+Position_D-Position_B)/4.0/(a_PARAMETER+b_PARAMETER);
            Last_Target_X=NOW_X;//纠正限速器状态
            Last_Target_Y=NOW_Y;//
            Last_Target_Z=NOW_Z;//
        }
    }
    Run_Flag=1;
    Move_X=msg.x*82.7605720;
    Move_Y=msg.y*82.7605720;
    Move_Z=msg.z;//waiting
    if(relative==1)
        pending_flag=1;
}

void callback_speedlimit(const std_msgs::Float64& msg)//cm/s
{
    RC_Velocity=msg.data/2.41660968;
}

void callback_mode(const std_msgs::UInt8& msg)//pos_mode 0:absolute 1:relative
{
    if(relative!=msg.data)//mode changed
    {
        if(Run_Flag==1&&relative==1)//in position mode,want to change to absolute mode from relative mode
        {
            double NOW_X,NOW_Y,NOW_Z;
            NOW_X=(Position_B-Position_A)/2.0;
            NOW_Y=(Position_B+Position_C)/2.0;
            NOW_Z=(Position_C-Position_A+Position_D-Position_B)/4.0/(a_PARAMETER+b_PARAMETER);
            Last_Target_X=NOW_X;//纠正限速器状态
            Last_Target_Y=NOW_Y;
            Last_Target_Z=NOW_Z;
            Move_X=NOW_X;//纠正目标坐标
            Move_Y=NOW_Y;
            Move_Z=NOW_Z;
        }
        relative=msg.data;
    }
}
void publish_pos()
{
    double NOW_X,NOW_Y,NOW_Z;
    NOW_X=(Position_B-Position_A)/2.0;
    NOW_Y=(Position_B+Position_C)/2.0;
    NOW_Z=(Position_C-Position_A+Position_D-Position_B)/4.0/(a_PARAMETER+b_PARAMETER);
		pos_msg.x=NOW_X/82.7605720;
	pos_msg.y=NOW_Y/82.7605720;
	pos_msg.z=NOW_Z;//waiting
		current_pos.publish(&pos_msg);
}